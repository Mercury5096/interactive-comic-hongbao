<!DOCTYPE html>
<html lang="zh-Hant">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>äº’å‹•å¼é é¢æ¼«ç•« Â· SVGæ‹–æ›³é è¦½(å°é½Šç„¡åç§»)</title>
  <style>
    :root {
      --max: 1100px;
      --hint: rgba(255, 255, 255, .08);
      --accent: rgba(255, 255, 255, .35);
    }

    html,
    body {
      margin: 0;
      background: #0b0f14;
      color: #e8f0ff;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, 'Noto Sans TC', sans-serif;
    }

    header {
      max-width: var(--max);
      margin: 16px auto 6px;
      padding: 0 16px;
    }

    header h1 {
      font-size: 18px;
      margin: 0 0 4px;
    }

    header p {
      margin: 0;
      opacity: .85;
      font-size: 14px;
    }

    .wrap {
      display: grid;
      place-items: center;
      padding: 10px 16px 80px;
    }

    .page {
      position: relative;
      width: min(100%, var(--max));
    }

    .page img {
      width: 100%;
      height: auto;
      display: block;
      border-radius: 12px;
      box-shadow: 0 12px 28px rgba(0, 0, 0, .45);
    }

    .overlay {
      position: absolute;
      inset: 0;
      border-radius: 12px;
      pointer-events: none;
    }

    .overlay svg {
      width: 100%;
      height: 100%;
      display: block;
    }

    .hs {
      pointer-events: all;
    }

    .hs rect {
      fill: var(--hint);
      stroke: var(--accent);
      stroke-width: 2;
      rx: 8;
      transition: .12s;
    }

    .hs:hover rect,
    .hs:focus rect {
      fill: rgba(255, 255, 255, .16);
      stroke: #fff;
      outline: none;
    }

    .ui {
      position: fixed;
      left: 16px;
      right: 16px;
      bottom: 16px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }

    .pill {
      background: rgba(17, 25, 34, .7);
      border: 1px solid rgba(255, 255, 255, .15);
      border-radius: 999px;
      padding: 8px 12px;
      font-size: 14px;
    }

    .btn {
      cursor: pointer;
      user-select: none;
    }

    .btn[aria-pressed="true"] {
      background: rgba(64, 128, 255, .22);
      border-color: rgba(160, 200, 255, .5);
    }

    /* ç·¨è¼¯æ¨¡å¼ */
    .edit .overlay {
      cursor: crosshair;
      pointer-events: all;
    }

    .exportbox {
      position: fixed;
      right: 16px;
      bottom: 72px;
      background: rgba(15, 23, 32, .95);
      border: 1px solid rgba(255, 255, 255, .15);
      border-radius: 12px;
      padding: 10px;
      width: min(520px, 92vw);
    }

    .exportbox textarea {
      width: 100%;
      height: 160px;
      background: #0b0f14;
      color: #e8f0ff;
      border: 1px solid rgba(255, 255, 255, .15);
      border-radius: 8px;
      padding: 6px;
      font-family: ui-monospace, Menlo, Consolas, monospace;
      font-size: 12px;
    }

    .small {
      opacity: .78;
      font-size: 12px;
    }

    /* === editor: è¼¸å‡ºæ¡†è®Šçª„ + å¯ç¸®æ”¾ + æ‹–æ›³æ‰‹æŠŠæ¨£å¼ === */
    .exportbox {
      width: min(380px, 80vw);
      /* åŸæœ¬ 520 â†’ 380ï¼Œè¼ƒä¸æ“‹ç•«é¢ */
      max-height: 60vh;
      overflow: auto;
      resize: both;
      /* å³ä¸‹è§’å¯æ‹–æ‹‰æ”¹å¤§å° */
      z-index: 10000;
      /* è®“å®ƒåœ¨ä¸Šå±¤ */
    }

    .exportbox .drag-handle {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 6px;
      cursor: move;
      user-select: none;
      touch-action: none;
      /* æ‰‹æ©Ÿä¹Ÿå¥½æ‹– */
    }
  </style>
</head>

<body>
  <header>
    <h1>äº’å‹•å¼é é¢æ¼«ç•«ï¼ˆç¬¬ 10 é  / SVG é è¦½ç„¡åç§»ï¼‰</h1>
    <p>é»å·¦ä¸‹ã€Œç·¨è¼¯æ¨¡å¼ã€â†’ ç›´æ¥åœ¨åœ–ä¸Šæ‹–æ‹‰çŸ©å½¢ï¼ˆé è¦½=çµæœï¼‰â†’ å³ä¸‹è§’è¼¸å‡º JSONã€‚<br>
      å¦‚éœ€æ›åœ–ï¼Œæ›´æ–°ä¸‹æ–¹ &lt;img&gt; çš„ <code>src</code>ï¼Œå…¶é¤˜è‡ªå‹•åµæ¸¬ã€‚</p>
  </header>

  <div class="wrap">
    <div class="page" id="page">
      <!-- â˜… è‹¥ä½ ç›®å‰çš„æª”åæ˜¯ assets/images/pg19.webpï¼Œä¿æŒä¸è®Šå³å¯ -->
      <img id="pageImg" src="assets/images/pg19.webp" alt="Page 19" />
      <div class="overlay" id="overlay">
        <!-- æˆ‘å€‘ç”¨åŒä¸€å€‹ SVG åŒæ™‚é¡¯ç¤ºã€Œæ—¢æœ‰ç†±å€ã€èˆ‡ã€Œæ‹–æ›³é è¦½æ¡†ã€ -->
        <svg id="svg" viewBox="0 0 10 10" preserveAspectRatio="none" aria-hidden="true">
          <g id="hotspotLayer"></g>
          <!-- æ‹–æ›³æ™‚çš„å³æ™‚é è¦½çŸ©å½¢ -->
          <rect id="dragRect" x="0" y="0" width="0" height="0" fill="rgba(255,255,255,.14)"
            stroke="rgba(255,255,255,.85)" stroke-width="2" rx="8" style="display:none;"></rect>
        </svg>
      </div>
    </div>
  </div>

  <div class="ui">
    <button id="editBtn" class="pill btn" aria-pressed="false">ğŸ–Šï¸ ç·¨è¼¯æ¨¡å¼ï¼šé—œ</button>
    <div class="pill small">æ‹–æ‹‰å»ºç«‹çŸ©å½¢ï¼›æ”¾é–‹å¾Œå³ä¸‹è§’æœƒé¡¯ç¤º JSONã€‚</div>
  </div>
  <div class="exportbox" id="exportBox" hidden>
    <div class="drag-handle">
      <strong>ç†±å€ JSON</strong>
      <span class="small" style="opacity:.8;">å¯æ‹–å‹•åˆ°ä»»æ„ä½ç½®</span>
    </div>
    <div style="margin:0 0 6px 2px;opacity:.9">
      æŠŠä¸‹æ–¹ JSON ç‰‡æ®µè²¼åˆ°ä½ çš„è¨­å®šæª”ï¼ˆ<code>hotspots</code> é™£åˆ—ï¼‰
    </div>
    <textarea id="exportTxt" readonly></textarea>
  </div>


  <script>
    let PAGE_W = null, PAGE_H = null;
    let hotspots = []; // ä½ æ¡†å¥½çš„æ ¼å­å¯ä»¥è²¼å›é€™è£¡é è¦½

    const img = document.getElementById('pageImg');
    const overlay = document.getElementById('overlay');
    const svg = document.getElementById('svg');
    const layer = document.getElementById('hotspotLayer');
    const dragRect = document.getElementById('dragRect');

    const editBtn = document.getElementById('editBtn');
    const exportBox = document.getElementById('exportBox');
    const exportTxt = document.getElementById('exportTxt');

    let editing = false;
    let dragging = false;
    let startPt = null; // {x,y} in SVG coords

    // === editor: exportBox å¯æ‹–æ›³ + è¨˜ä½ä½ç½® ===
    (function initExportBoxDrag() {
      const handle = exportBox.querySelector('.drag-handle') || exportBox;

      // é‚„åŸä¸Šæ¬¡ä½ç½®
      try {
        const saved = JSON.parse(localStorage.getItem('editor_exportbox_pos') || 'null');
        if (saved && Number.isFinite(saved.left) && Number.isFinite(saved.top)) {
          exportBox.style.left = saved.left + 'px';
          exportBox.style.top = saved.top + 'px';
          exportBox.style.right = 'auto';
          exportBox.style.bottom = 'auto';
        }
      } catch (e) { }

      let sx = 0, sy = 0, sl = 0, st = 0, moving = false;
      function onDown(ev) {
        if (ev.button !== 0 && ev.pointerType === 'mouse') return;
        ev.preventDefault();
        const r = exportBox.getBoundingClientRect();
        sx = ev.clientX; sy = ev.clientY; sl = r.left; st = r.top; moving = true;
        exportBox.style.right = 'auto'; exportBox.style.bottom = 'auto';
        window.addEventListener('pointermove', onMove);
        window.addEventListener('pointerup', onUp, { once: true });
      }
      function onMove(ev) {
        if (!moving) return;
        const left = sl + (ev.clientX - sx);
        const top = st + (ev.clientY - sy);
        exportBox.style.left = left + 'px';
        exportBox.style.top = top + 'px';
      }
      function onUp() {
        moving = false;
        window.removeEventListener('pointermove', onMove);
        try {
          const left = parseInt(exportBox.style.left || '0', 10) || 0;
          const top = parseInt(exportBox.style.top || '0', 10) || 0;
          localStorage.setItem('editor_exportbox_pos', JSON.stringify({ left, top }));
        } catch (e) { }
      }
      handle.addEventListener('pointerdown', onDown);
    })();


    // 1) è‡ªå‹•åµæ¸¬åœ–ç‰‡åŸå§‹å°ºå¯¸ â†’ è¨­å®š viewBox
    function setupViewBox() {
      PAGE_W = img.naturalWidth;
      PAGE_H = img.naturalHeight;
      svg.setAttribute('viewBox', `0 0 ${PAGE_W} ${PAGE_H}`);
      renderHotspots();
    }
    if (img.complete && img.naturalWidth) setupViewBox();
    else img.addEventListener('load', setupViewBox);

    // 2) æ¸²æŸ“æ—¢æœ‰ç†±å€
    function renderHotspots() {
      layer.innerHTML = '';
      (hotspots || []).forEach(h => {
        const a = document.createElementNS('http://www.w3.org/2000/svg', 'a');
        a.setAttribute('class', 'hs'); a.setAttribute('href', '#'); a.setAttribute('tabindex', '0'); a.dataset.id = h.id || '';
        const r = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        r.setAttribute('x', h.x); r.setAttribute('y', h.y);
        r.setAttribute('width', h.width); r.setAttribute('height', h.height);
        r.setAttribute('rx', 8);
        a.appendChild(r);
        layer.appendChild(a);
      });
    }

    // 3) ç·¨è¼¯æ¨¡å¼åˆ‡æ›
    function setEditMode(val) {
      editing = val;
      document.body.classList.toggle('edit', editing);
      exportBox.hidden = !editing;
      editBtn.setAttribute('aria-pressed', String(editing));
      editBtn.textContent = editing ? 'ğŸ–Šï¸ ç·¨è¼¯æ¨¡å¼ï¼šé–‹' : 'ğŸ–Šï¸ ç·¨è¼¯æ¨¡å¼ï¼šé—œ';
      if (!editing) endDrag(); // é—œé–‰æ™‚æ¸…é™¤æ‹–æ›³
    }
    editBtn.addEventListener('click', () => setEditMode(!editing));

    // 4) å°‡ clientX/Y è½‰ç‚º SVGï¼ˆåœ–ç‰‡åŸå§‹åƒç´ ï¼‰åº§æ¨™
    function clientToSvgPoint(clientX, clientY) {
      const r = overlay.getBoundingClientRect();
      const nx = (clientX - r.left) / r.width;
      const ny = (clientY - r.top) / r.height;
      return {
        x: Math.max(0, Math.min(PAGE_W, nx * PAGE_W)),
        y: Math.max(0, Math.min(PAGE_H, ny * PAGE_H))
      };
    }

    // 5) æ‹–æ›³æµç¨‹ï¼ˆpointer äº‹ä»¶åŒæ™‚æ”¯æ´æ»‘é¼ /è§¸æ§/æ‰‹å¯«ç­†ï¼‰
    overlay.addEventListener('pointerdown', (ev) => {
      if (!editing || PAGE_W == null) return;
      overlay.setPointerCapture(ev.pointerId);
      dragging = true;
      startPt = clientToSvgPoint(ev.clientX, ev.clientY);
      // åˆå§‹åŒ–é è¦½æ¡†
      dragRect.style.display = 'block';
      dragRect.setAttribute('x', startPt.x);
      dragRect.setAttribute('y', startPt.y);
      dragRect.setAttribute('width', 0);
      dragRect.setAttribute('height', 0);
    });

    overlay.addEventListener('pointermove', (ev) => {
      if (!dragging || !editing) return;
      const p = clientToSvgPoint(ev.clientX, ev.clientY);
      const x = Math.min(startPt.x, p.x);
      const y = Math.min(startPt.y, p.y);
      const w = Math.abs(startPt.x - p.x);
      const h = Math.abs(startPt.y - p.y);
      dragRect.setAttribute('x', x);
      dragRect.setAttribute('y', y);
      dragRect.setAttribute('width', w);
      dragRect.setAttribute('height', h);
    });

    function endDrag(ev) {
      if (!dragging) return;
      dragging = false;
      // è‹¥ mouseup ç™¼ç”Ÿåœ¨å¤–é¢ï¼Œç”¨æœ€å¾Œä¸€æ¬¡ dragRect å°ºå¯¸ï¼›å¦å‰‡ç”¨äº‹ä»¶åº§æ¨™
      let x = parseFloat(dragRect.getAttribute('x'));
      let y = parseFloat(dragRect.getAttribute('y'));
      let w = parseFloat(dragRect.getAttribute('width'));
      let h = parseFloat(dragRect.getAttribute('height'));
      if (ev && ev.clientX != null) {
        const p = clientToSvgPoint(ev.clientX, ev.clientY);
        x = Math.round(Math.min(startPt.x, p.x));
        y = Math.round(Math.min(startPt.y, p.y));
        w = Math.round(Math.abs(startPt.x - p.x));
        h = Math.round(Math.abs(startPt.y - p.y));
      } else {
        // ä¿éšªå–æ•´
        x = Math.round(x); y = Math.round(y);
        w = Math.round(w); h = Math.round(h);
      }
      // æ¸…é™¤é è¦½
      dragRect.style.display = 'none';
      dragRect.setAttribute('width', 0);
      dragRect.setAttribute('height', 0);

      // å¿½ç•¥é›¶é¢ç©æ‹–æ›³
      if (w <= 0 || h <= 0) return;

      const id = 'p' + String((hotspots?.length || 0) + 1).padStart(2, '0');
      const snippet = { id, x, y, width: w, height: h, action: { type: 'none' } };
      exportTxt.value = JSON.stringify(snippet, null, 2);
      // å³æ™‚åŠ åˆ°é è¦½
      hotspots.push(snippet);
      renderHotspots();
    }

    overlay.addEventListener('pointerup', endDrag);
    overlay.addEventListener('pointercancel', endDrag);

    // 6) ä»£ç†é»æ“Šï¼ˆä¹‹å¾Œç”¨ä¾†è§¸ç™¼ actionï¼Œä¾‹å¦‚ swapFramesï¼‰
    // äº‹ä»¶åˆ†æ´¾ï¼ˆçµ±ä¸€å…¥å£ï¼‰â€” åƒ…æ­¤ä¸€å€‹ï¼Œä¸è¦å†å·¢ç‹€æ–°å¢ç›£è½å™¨
    svg.addEventListener('click', async (ev) => {
      // å…ˆå˜—è©¦å¾äº‹ä»¶ç›®æ¨™å¾€ä¸Šæ‰¾ .hs
      let node = ev.target.closest('.hs');

      // æ‰¾ä¸åˆ°å°±ç”¨åº§æ¨™åš fallback å‘½ä¸­æ¸¬è©¦
      if (!node) {
        const pt = svg.createSVGPoint();
        pt.x = ev.clientX;
        pt.y = ev.clientY;
        const ctm = svg.getScreenCTM();
        if (ctm) {
          const p = pt.matrixTransform(ctm.inverse());
          const hsList = [...hotspotLayer.querySelectorAll('.hs')];
          // å¾æœ€ä¸Šå±¤é–‹å§‹æ‰¾ï¼ˆå¾Œæ’å…¥çš„åœ¨æœ€ä¸Šé¢ï¼‰
          for (let i = hsList.length - 1; i >= 0; i--) {
            const g = hsList[i];
            if (g.style.pointerEvents === 'none') continue;
            const r = g.querySelector('rect'); if (!r) continue;
            const x = parseFloat(r.getAttribute('x')) || 0;
            const y = parseFloat(r.getAttribute('y')) || 0;
            const w = parseFloat(r.getAttribute('width')) || 0;
            const h = parseFloat(r.getAttribute('height')) || 0;
            if (p.x >= x && p.x <= x + w && p.y >= y && p.y <= y + h) { node = g; break; }
          }
        }
      }
      if (!node) return;

      ev.preventDefault();

      const id = node.dataset.id;
      const h = (cfg.hotspots || []).find(x => x.id === id);
      if (!h || !h.action) return;

      // é»æ“Šç•¶ä¸‹å°±æ”¶æ‰é»ƒæ¡† + åœç”¨é»æ“Š
      node.classList.add('done');
      node.style.pointerEvents = 'none';

      await runAction(h, withDefaults(h.action));
    });


  </script>